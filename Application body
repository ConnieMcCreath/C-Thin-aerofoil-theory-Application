using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace NACA_4_digit_and_5_digit
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }
        
        private void Form1_Load(object sender, EventArgs e)
        {   
            //defining inital form inputs
            string aerofoil = textBox1.Text;
            string alphaDeg = textBox2.Text;
            //error message for user if inputs are not recognised
            textBox17.Text = "Invalid Input!";
            textBox17.Visible = false;
        }
        //aerofoil data extraction button
        private void button1_Click(object sender, EventArgs e)
        {
            string aerofoil = textBox1.Text;
            double alphaDeg = Convert.ToDouble(textBox2.Text);
            //convert angle of attack to radians
            double alphaRad = alphaDeg * Math.PI / 180;

            //NACA 4-digit data extraction
            if (aerofoil.Length == 4)
            {
                double locationData = Convert.ToDouble(aerofoil.Substring(1, 1));

                //Camber, position of max camber and thickness displayed
                textBox3.Text = aerofoil.Substring(0, 1) + "%";
                textBox4.Text = locationData * 10 + "%";
                textBox5.Text = aerofoil.Substring(2, 2) + "%";
                //unused textboxes
                textBox6.Visible = false;
                textBox7.Visible = false;
                textBox8.Visible = false;
            }
            //NACA 4-digit data extraction
            else if (aerofoil.Length == 5)
            {
                double locationData = Convert.ToDouble(aerofoil.Substring(1, 2));
                double ceofLiftData = Convert.ToDouble(aerofoil.Substring(0, 1));
                double camberGeo = Convert.ToDouble(aerofoil.Substring(2, 1));

                //define trailing edge 
                if (NACA5AerofoilValidity(locationData) == true)
                {
                    if (camberGeo == 0)
                        textBox3.Text = "normal";
                    else
                    {
                        textBox3.Text = "reflex";
                    }
                }
                else
                    textBox17.Visible = true;

                if (camberGeo == 0)
                    textBox4.Text = locationData / 2 + "%";
                else

                //define aerofoil data extraction values
                textBox4.Text = (locationData - 1) / 2 + "%";
                textBox5.Text = aerofoil.Substring(3, 2) + "%";
                textBox6.Text = ceofLiftData * 0.15 + " ";
                textBox7.Text = Convert.ToString(k1Value(locationData));
                textBox8.Text = Convert.ToString(rValue(locationData));
            }
            //warning message
            else
                textBox17.Visible = true;
        }
        //Analytical method button
        private void button3_Click(object sender, EventArgs e)
        {
            string aerofoil = textBox1.Text;
            double alphaDeg = Convert.ToDouble(textBox2.Text);
            double alphaRad = alphaDeg * Math.PI / 180;

            //NACA 4 aerofoil
            if (aerofoil.Length == 4)
            {
                //max camber location in polar coordinates
                double m = Convert.ToDouble(aerofoil.Substring(0, 1)) / 100;
                double p = Convert.ToDouble(aerofoil.Substring(1, 1)) / 10;

                //convert to cartesian 
                double limit = Math.Acos(1 - 2 * p);
                textBox9.Text = Convert.ToString(limit);

                double A0Integration = (1 / Math.PI) * (NACA4A0IntFront(m, p, limit) - NACA4A0IntFront(m, p, 0) + NACA4A0IntRear(m, p, Math.PI) - NACA4A0IntRear(m, p, limit));
                double A0 = alphaRad - A0Integration;
                textBox10.Text = Convert.ToString(A0);

                double A1 = (2 / Math.PI) * (NACA4A1IntFront(m, p, limit) - NACA4A1IntFront(m, p, 0) + NACA4A1IntRear(m, p, Math.PI) - NACA4A1IntRear(m, p, limit));
                textBox11.Text = Convert.ToString(A1);

                double A2 = (2 / Math.PI) * (NACA4A2IntFront(m, p, limit) - NACA4A2IntFront(m, p, 0) + NACA4A2IntRear(m, p, Math.PI) - NACA4A2IntRear(m, p, limit));
                textBox12.Text = Convert.ToString(A2);

                //defining CL, CMle, CMqc and alpha at zero lift outputs
                textBox13.Text = Convert.ToString(Math.PI * (2 * A0 + A1));
                textBox14.Text = Convert.ToString(-1 * Math.PI * (A0 + A1 - A2 / 2) / 2);
                textBox15.Text = Convert.ToString(-1 * Math.PI * (A1 - A2) / 4);
                textBox16.Text = Convert.ToString((A0Integration - A1 / 2) * 180 / Math.PI);

            }
            //NACA 5
            else if (aerofoil.Length == 5)
            {
                double locationData = Convert.ToDouble(aerofoil.Substring(1, 2));
                double ceofLiftData = Convert.ToDouble(aerofoil.Substring(0, 1));
                double camberGeo = Convert.ToDouble(aerofoil.Substring(2, 1));

                //check for invalid aerofoil input
                if (NACA5AerofoilValidity(locationData) == false) { 
                    textBox17.Visible = true;
                }
                else
                {
                    //aerofoil data extraction
                    textBox4.Text = locationData / 2 + "%";
                    textBox5.Text = aerofoil.Substring(3, 2) + "%";
                    textBox6.Text = ceofLiftData * 0.15 + " ";

                    //extracting correct data from methods
                    double k1 = k1Value(locationData);
                    double r = rValue(locationData);
                    double k2Overk1 = k2Overk1Value(locationData);
                    double k2 = k1 * k2Overk1;
                    double limit = Math.Acos(1 - 2 * r);
                    textBox7.Text = k1.ToString();
                    textBox8.Text = r.ToString();
                    textBox9.Text = limit.ToString();

                    double A0Integration;
                    double A0;
                    double A1;
                    double A2;

                    //for normal trailing edge analytical method
                    if (camberGeo == 0)
                    {
                        A0Integration = (1 / Math.PI) * (NACA5A0IntNormalFront(k1, r, limit) - NACA5A0IntNormalFront(k1, r, 0) + NACA5A0IntNormalRear(k1, r, Math.PI) - NACA5A0IntNormalRear(k1, r, limit));
                        A0 = alphaRad - A0Integration;
                        A1 = (2 / Math.PI) * (NACA5A1IntNormalFront(k1, r, limit) - NACA5A1IntNormalFront(k1, r, 0) + NACA5A1IntNormalRear(k1, r, Math.PI) - NACA5A1IntNormalRear(k1, r, limit));
                        A2 = (2 / Math.PI) * (NACA5A2IntNormalFront(k1, r, limit) - NACA5A2IntNormalFront(k1, r, 0) + NACA5A2IntNormalRear(k1, r, Math.PI) - NACA5A2IntNormalRear(k1, r, limit));
                        textBox10.Text = A0.ToString();
                        textBox11.Text = A1.ToString();
                        textBox12.Text = A2.ToString();
                        textBox13.Text = Convert.ToString(Math.PI * (2 * A0 + A1));
                        textBox14.Text = Convert.ToString(-1 * Math.PI * (A0 + A1 - A2 / 2) / 2);
                        textBox15.Text = Convert.ToString(-1 * Math.PI * (A1 - A2) / 4);
                        textBox16.Text = Convert.ToString((A0Integration - A1 / 2) * 180 / Math.PI);
                    }
                    //for reflexed trailing edge analytical method
                    else if (camberGeo == 1)
                    {
                        A0Integration = (1 / Math.PI) * (NACA5A0IntReflexFront(k1, k2, r, limit) - NACA5A0IntReflexFront(k1, k2, r, 0) + NACA5A0IntReflexRear(k1, k2, r, Math.PI) - NACA5A0IntReflexRear(k1, k2, r, limit));
                        A0 = alphaRad - A0Integration;
                        textBox10.Text = A0.ToString();

                        A1 = (2 / Math.PI) * (NACA5A1IntReflexFront(k1, k2, r, limit) - NACA5A1IntReflexFront(k1, k2, r, 0) + NACA5A1IntReflexRear(k1, k2, r, Math.PI) - NACA5A1IntReflexRear(k1, k2, r, limit));
                        textBox11.Text = A1.ToString();

                        A2 = (2 / Math.PI) * (NACA5A2IntReflexFront(k1, k2, r, limit) - NACA5A2IntReflexFront(k1, k2, r, 0) + NACA5A2IntReflexRear(k1, k2, r, Math.PI) - NACA5A2IntReflexRear(k1, k2, r, limit));
                        textBox12.Text = A2.ToString();
                            
                        textBox13.Text = Convert.ToString(Math.PI * (2 * A0 + A1));
                        textBox14.Text = Convert.ToString(-1 * Math.PI * (A0 + A1 - A2 / 2) / 2);
                        textBox15.Text = Convert.ToString(-1 * Math.PI * (A1 - A2) / 4);
                        textBox16.Text = Convert.ToString((A0Integration - A1 / 2) * 180 / Math.PI);
                        
                    }
                    //warning message
                    else
                        textBox17.Visible = true;
                }
            }
        }
        //Numerical method button
        private void button4_Click(object sender, EventArgs e)
        {
            string aerofoil = textBox1.Text;
            double alphaDeg = Convert.ToDouble(textBox2.Text);
            double alphaRad = alphaDeg * Math.PI / 180;
            double locationData = Convert.ToDouble(aerofoil.Substring(1, 2));
            double k1 = k1Value(locationData);
            double r = rValue(locationData);
            double k2Overk1 = k2Overk1Value(locationData);
            double k2 = k1 * k2Overk1;
            double limit;
            
            // number of increments of front and back section (n*2 in total)
            int n = 6;
            
            if (aerofoil.Length == 5 && textBox3.Text == "normal")
            {
                limit = Math.Acos(1 - 2 * r);
                textBox9.Text = limit.ToString();
                //define step sizes
                double deltaX_fore = (limit - 0) / n;
                double deltaX_aft = (Math.PI - limit) / n;

                //Simpson's Rule for numerical integration A0
                double A05_fore_SR = (deltaX_fore / 3) * (A05_foreS(k1, r, 0) + 4 * A05_foreS(k1, r, (deltaX_fore)) + 2 * A05_foreS(k1, r, (2 * deltaX_fore)) + 4 * A05_foreS(k1, r, (3 * deltaX_fore)) + 2 * A05_foreS(k1, r, (4 * deltaX_fore)) + 4 * A05_foreS(k1, r, (5 * deltaX_fore)) + A05_foreS(k1, r, (limit)));
                double A05_aft_SR = (deltaX_aft / 3) * (A05_aftS(k1, r, limit) + 4 * A05_aftS(k1, r, (limit + deltaX_aft)) + 2 * A05_aftS(k1, r, (limit + 2 * deltaX_aft)) + 4 * A05_aftS(k1, r, (limit + 3 * deltaX_aft)) + 2 * A05_aftS(k1, r, (limit + 4 * deltaX_aft)) + 4 * A05_aftS(k1, r, (limit + 5 * deltaX_aft)) + A05_aftS(k1, r, (Math.PI)));
                double A0Integration = (1 / Math.PI) * (A05_fore_SR + A05_aft_SR);
                double A0 = alphaRad - A0Integration;
                textBox10.Text = A0.ToString();

                //Simpson's Rule for numerical integration A1
                double A15_fore_SR = (deltaX_fore / 3) * (A15_foreS(k1, r, 0) + 4 * A15_foreS(k1, r, (deltaX_fore)) + 2 * A15_foreS(k1, r, (2 * deltaX_fore)) + 4 * A15_foreS(k1, r, (3 * deltaX_fore)) + 2 * A15_foreS(k1, r, (4 * deltaX_fore)) + 4 * A15_foreS(k1, r, (5 * deltaX_fore)) + A15_foreS(k1, r, (limit)));
                double A15_aft_SR = (deltaX_aft / 3) * (A15_aftS(k1, r, limit) + 4 * A15_aftS(k1, r, (limit + deltaX_aft)) + 2 * A15_aftS(k1, r, (limit + 2 * deltaX_aft)) + 4 * A15_aftS(k1, r, (limit + 3 * deltaX_aft)) + 2 * A15_aftS(k1, r, (limit + 4 * deltaX_aft)) + 4 * A15_aftS(k1, r, (limit + 5 * deltaX_aft)) + A15_aftS(k1, r, (Math.PI)));
                double A1 = (2/Math.PI)*(A15_fore_SR+A15_aft_SR);
                textBox11.Text = A1.ToString();

                //Simpson's Rule for numerical integration A2
                double A25_fore_SR = (deltaX_fore / 3) * (A25_foreS(k1, r, 0) + 4 * A25_foreS(k1, r, (deltaX_fore)) + 2 * A25_foreS(k1, r, (2 * deltaX_fore)) + 4 * A25_foreS(k1, r, (3 * deltaX_fore)) + 2 * A25_foreS(k1, r, (4 * deltaX_fore)) + 4 * A25_foreS(k1, r, (5 * deltaX_fore)) + A25_foreS(k1, r, (limit)));
                double A25_aft_SR = (deltaX_aft / 3) * (A25_aftS(k1, r, limit) + 4 * A25_aftS(k1, r, (limit + deltaX_aft)) + 2 * A25_aftS(k1, r, (limit + 2 * deltaX_aft)) + 4 * A25_aftS(k1, r, (limit + 3 * deltaX_aft)) + 2 * A25_aftS(k1, r, (limit + 4 * deltaX_aft)) + 4 * A25_aftS(k1, r, (limit + 5 * deltaX_aft)) + A25_aftS(k1, r, (Math.PI)));
                double A2 = (2 / Math.PI) * (A25_fore_SR + A25_aft_SR);
                textBox12.Text = A2.ToString();

                //display output values
                textBox13.Text = Convert.ToString(Math.PI * (2 * A0 + A1));
                textBox14.Text = Convert.ToString(-1 * Math.PI * (A0 + A1 - A2 / 2) / 2);
                textBox15.Text = Convert.ToString(-1 * Math.PI * (A1 - A2) / 4);
                textBox16.Text = Convert.ToString((A0Integration - A1 / 2) * 180 / Math.PI);
            }
            
            else if (aerofoil.Length == 5 && textBox3.Text == "reflex")
            {

                limit = Math.Acos(1 - 2 * r);
                textBox9.Text = limit.ToString();
                //step sizes
                double deltaX_fore = (limit - 0) / n;
                double deltaX_aft = (Math.PI - limit) / n;

                //Simpson's Rule for numerical integration A0
                double A05_fore_SR = (deltaX_fore / 3) * (A05_foreReflexSR(k1, k2Overk1, r, 0) + 4 * A05_foreReflexSR(k1, k2Overk1, r, (deltaX_fore)) + 2 * A05_foreReflexSR(k1, k2Overk1, r, (2 * deltaX_fore)) + 4 * A05_foreReflexSR(k1, k2Overk1, r, (3 * deltaX_fore)) + 2 * A05_foreReflexSR(k1, k2Overk1, r, (4 * deltaX_fore)) + 4 * A05_foreReflexSR(k1, k2Overk1, r, (5 * deltaX_fore)) + A05_foreReflexSR(k1, k2Overk1, r, (limit)));
                double A05_aft_SR = (deltaX_aft / 3) * (A05_aftReflexSR(k1, k2Overk1, r, limit) + 4 * A05_aftReflexSR(k1, k2Overk1, r, (limit + deltaX_aft)) + 2 * A05_aftReflexSR(k1, k2Overk1, r, (limit + 2 * deltaX_aft)) + 4 * A05_aftReflexSR(k1, k2Overk1, r, (limit + 3 * deltaX_aft)) + 2 * A05_aftReflexSR(k1, k2Overk1, r, (limit + 4 * deltaX_aft)) + 4 * A05_aftReflexSR(k1, k2Overk1, r, (limit + 5 * deltaX_aft)) + A05_aftReflexSR(k1, k2Overk1, r, (Math.PI)));
                double A0Integration = (1 / Math.PI) * (A05_fore_SR + A05_aft_SR);
                double A0 = alphaRad - A0Integration;
                textBox10.Text = A0.ToString();

                //Simpson's Rule for numerical integration A1
                double A15_fore_SR = (deltaX_fore / 3) * (A15_foreReflexSR(k1, k2Overk1, r, 0) + 4 * A15_foreReflexSR(k1, k2Overk1, r, (deltaX_fore)) + 2 * A15_foreReflexSR(k1, k2Overk1, r, (2 * deltaX_fore)) + 4 * A15_foreReflexSR(k1, k2Overk1, r, (3 * deltaX_fore)) + 2 * A15_foreReflexSR(k1, k2Overk1, r, (4 * deltaX_fore)) + 4 * A15_foreReflexSR(k1, k2Overk1, r, (5 * deltaX_fore)) + A15_foreReflexSR(k1, k2Overk1, r, (limit)));
                double A15_aft_SR = (deltaX_aft / 3) * (A15_aftReflexSR(k1, k2Overk1, r, limit) + 4 * A15_aftReflexSR(k1, k2Overk1, r, (limit + deltaX_aft)) + 2 * A15_aftReflexSR(k1, k2Overk1, r, (limit + 2 * deltaX_aft)) + 4 * A15_aftReflexSR(k1, k2Overk1, r, (limit + 3 * deltaX_aft)) + 2 * A15_aftReflexSR(k1, k2Overk1, r, (limit + 4 * deltaX_aft)) + 4 * A15_aftReflexSR(k1, k2Overk1, r, (limit + 5 * deltaX_aft)) + A15_aftReflexSR(k1, k2Overk1, r, (Math.PI)));
                double A1 = (2 / Math.PI) * (A15_fore_SR + A15_aft_SR);
                textBox11.Text = A1.ToString();

                //Simpson's Rule for numerical integration A2
                double A25_fore_SR = (deltaX_fore / 3) * (A25_foreReflexSR(k1, k2Overk1, r, 0) + 4 * A25_foreReflexSR(k1, k2Overk1, r, (deltaX_fore)) + 2 * A25_foreReflexSR(k1, k2Overk1, r, (2 * deltaX_fore)) + 4 * A25_foreReflexSR(k1, k2Overk1, r, (3 * deltaX_fore)) + 2 * A25_foreReflexSR(k1, k2Overk1, r, (4 * deltaX_fore)) + 4 * A25_foreReflexSR(k1, k2Overk1, r, (5 * deltaX_fore)) + A25_foreReflexSR(k1, k2Overk1, r, (limit)));
                double A25_aft_SR = (deltaX_aft / 3) * (A25_aftReflexSR(k1, k2Overk1, r, limit) + 4 * A25_aftReflexSR(k1, k2Overk1, r, (limit + deltaX_aft)) + 2 * A25_aftReflexSR(k1, k2Overk1, r, (limit + 2 * deltaX_aft)) + 4 * A25_aftReflexSR(k1, k2Overk1, r, (limit + 3 * deltaX_aft)) + 2 * A25_aftReflexSR(k1, k2Overk1, r, (limit + 4 * deltaX_aft)) + 4 * A25_aftReflexSR(k1, k2Overk1, r, (limit + 5 * deltaX_aft)) + A25_aftReflexSR(k1, k2Overk1, r, (Math.PI)));
                double A2 = (2 / Math.PI) * (A25_fore_SR + A25_aft_SR);
                textBox12.Text = A2.ToString();

                textBox13.Text = Convert.ToString(Math.PI * (2 * A0 + A1));
                textBox14.Text = Convert.ToString(-1 * Math.PI * (A0 + A1 - A2 / 2) / 2);
                textBox15.Text = Convert.ToString(-1 * Math.PI * (A1 - A2) / 4);
                textBox16.Text = Convert.ToString((A0Integration - A1 / 2) * 180 / Math.PI);
            }
            //NACA 4 numerical integration method
            else if (aerofoil.Length == 4)
            {
                double m = Convert.ToDouble(aerofoil.Substring(0, 1)) / 100;
                double p = Convert.ToDouble(aerofoil.Substring(1, 1)) / 10;
                limit = Math.Acos(1 - 2 * p);
                textBox9.Text = Convert.ToString(limit);

                // step size
                double deltaX_fore = (limit - 0) / n;
                double deltaX_aft = (Math.PI - limit) / n;

                //Simpson's Rule for numerical integration A0
                double A04_fore_SR = (deltaX_fore / 3) * (A04_foreSR(m,p,0) + 4 * A04_foreSR(m, p, (deltaX_fore)) + 2 * A04_foreSR(m, p, (2 * deltaX_fore)) + 4 * A04_foreSR(m, p, (3 * deltaX_fore)) + 2 * A04_foreSR(m, p, (4 * deltaX_fore)) + 4 * A04_foreSR(m, p, (5 * deltaX_fore)) + A04_foreSR(m, p, (limit)));
                double A04_aft_SR = (deltaX_aft / 3) * (A04_aftSR(m, p, limit) + 4 * A04_aftSR(m, p, (limit + deltaX_aft)) + 2 * A04_aftSR(m, p, (limit + 2 * deltaX_aft)) + 4 * A04_aftSR(m, p, (limit + 3 * deltaX_aft)) + 2 * A04_aftSR(m, p, (limit + 4 * deltaX_aft)) + 4 * A04_aftSR(m, p, (limit + 5 * deltaX_aft)) + A04_aftSR(m, p, (Math.PI)));
                double A0Integration = (1 / Math.PI) * (A04_fore_SR + A04_aft_SR);
                double A0 = alphaRad - A0Integration;
                textBox10.Text = A0.ToString();

                //Simpson's Rule for numerical integration A1
                double A14_fore_SR = (deltaX_fore / 3) * (A14_foreSR(m, p, 0) + 4 * A14_foreSR(m, p, (deltaX_fore)) + 2 * A14_foreSR(m, p, (2 * deltaX_fore)) + 4 * A14_foreSR(m, p, (3 * deltaX_fore)) + 2 * A14_foreSR(m, p, (4 * deltaX_fore)) + 4 * A14_foreSR(m, p, (5 * deltaX_fore)) + A14_foreSR(m, p, (limit)));
                double A14_aft_SR = (deltaX_aft / 3) * (A14_aftSR(m, p, limit) + 4 * A14_aftSR(m, p, (limit + deltaX_aft)) + 2 * A14_aftSR(m, p, (limit + 2 * deltaX_aft)) + 4 * A14_aftSR(m, p, (limit + 3 * deltaX_aft)) + 2 * A14_aftSR(m, p, (limit + 4 * deltaX_aft)) + 4 * A14_aftSR(m, p, (limit + 5 * deltaX_aft)) + A14_aftSR(m, p, (Math.PI)));
                double A1 = (2 / Math.PI) * (A14_fore_SR + A14_aft_SR);
                textBox11.Text = A1.ToString();

                //Simpson's Rule for numerical integration A2
                double A24_fore_SR = (deltaX_fore / 3) * (A24_foreSR(m, p, 0) + 4 * A24_foreSR(m, p, (deltaX_fore)) + 2 * A24_foreSR(m, p, (2 * deltaX_fore)) + 4 * A24_foreSR(m, p, (3 * deltaX_fore)) + 2 * A24_foreSR(m, p, (4 * deltaX_fore)) + 4 * A24_foreSR(m, p, (5 * deltaX_fore)) + A24_foreSR(m, p, (limit)));
                double A24_aft_SR = (deltaX_aft / 3) * (A24_aftSR(m, p, limit) + 4 * A24_aftSR(m, p, (limit + deltaX_aft)) + 2 * A24_aftSR(m, p, (limit + 2 * deltaX_aft)) + 4 * A24_aftSR(m, p, (limit + 3 * deltaX_aft)) + 2 * A24_aftSR(m, p, (limit + 4 * deltaX_aft)) + 4 * A24_aftSR(m, p, (limit + 5 * deltaX_aft)) + A24_aftSR(m, p, (Math.PI)));
                double A2 = (2 / Math.PI) * (A24_fore_SR + A24_aft_SR);
                textBox12.Text = A2.ToString();

                textBox13.Text = Convert.ToString(Math.PI * (2 * A0 + A1));
                textBox14.Text = Convert.ToString(-1 * Math.PI * (A0 + A1 - A2 / 2) / 2);
                textBox15.Text = Convert.ToString(-1 * Math.PI * (A1 - A2) / 4);
                textBox16.Text = Convert.ToString((A0Integration - A1 / 2) * 180 / Math.PI);
            }
            
            else {}
        }


        //coefficient equations for NACA 5 normal gradient equations
        static double Aeq(double k1, double r)
        {
            return (k1 / 8) - (k1 * r / 2) + ((k1 * r * r) / 6) * (3 - r);
        }
        static double Beq(double k1, double r)
        {
            return (k1 * r / 2) - (k1 / 4);
        }
        static double Ceq(double k1)
        {
            return (k1 / 8);
        }
        static double Deq(double k1, double r)
        {
            return -((k1 * r * r * r) / 6);
        }

        //A0 front and rear equations to be integrated via Simpson's rule 
        static double A05_foreS(double k1, double r, double x)
        {
            return Aeq(k1, r) + Beq(k1, r) * Math.Cos(x) + Ceq(k1) * (Math.Pow(Math.Cos(x), 2));
        }
        static double A05_aftS(double k1, double r, double x)
        {
            return D(k1, r);
        }
        static double A05_foreReflexSR(double k1, double k2Overk1, double r, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return k1 / 6 * (3 * Math.Pow((z - r), 2) - k2Overk1 * Math.Pow((z - r), 3) - Math.Pow(r, 3));
        }
        static double A05_aftReflexSR(double k1, double k2Overk1, double r, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return k1 / 6 * (3 * k2Overk1 * Math.Pow((z - r), 2) - k2Overk1 * Math.Pow((z - r), 3) - Math.Pow(r, 3));
        }
        static double A04_foreSR(double m, double p, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return 2 * m / p - 2 * m * z / Math.Pow(p, 2);
        }
        static double A04_aftSR(double m, double p, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return 2 * m * p / (1 - p) - 2 * m * z / Math.Pow((1 - p), 2);
        }

        //A1 front and rear equations to be integrated via Simpson's rule 
        static double A15_foreS(double k1, double r, double x)
        {
            return A(k1, r) * Math.Cos(x) + B(k1, r) * (Math.Pow(Math.Cos(x), 2)) + C(k1) * (Math.Pow(Math.Cos(x), 3));
        }
        static double A15_aftS(double k1, double r, double x)
        {
            return D(k1, r) * Math.Cos(x);
        }
        static double A15_foreReflexSR(double k1, double k2Overk1, double r, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (k1 / 6 * (3 * Math.Pow((z - r), 2) - k2Overk1 * Math.Pow((z - r), 3) - Math.Pow(r, 3)))*Math.Cos(x);
        }
        static double A15_aftReflexSR(double k1, double k2Overk1, double r, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (k1 / 6 * (3 * k2Overk1 * Math.Pow((z - r), 2) - k2Overk1 * Math.Pow((z - r), 3) - Math.Pow(r, 3)))*Math.Cos(x);
        }
        static double A14_foreSR(double m, double p, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (2 * m / p - 2 * m * z / Math.Pow(p, 2))*Math.Cos(x);
        }
        static double A14_aftSR(double m, double p, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (2 * m * p / (1 - p) - 2 * m * z / Math.Pow((1 - p), 2))*Math.Cos(x);
        }

        //A2 ront and rear equations to be integrated via Simpson's rule 
        static double A25_foreS(double k1, double r, double x)
        {
            return A(k1, r) * Math.Cos(2 * x) + B(k1, r) * (Math.Cos(2 * x) * Math.Cos(x)) + C(k1) * ((Math.Pow(Math.Cos(x), 2)) * Math.Cos(2 * x));
        }
        static double A25_aftS(double k1, double r, double x)
        {
            return D(k1, r) * Math.Cos(2 * x);
        }
        static double A25_foreReflexSR(double k1, double k2Overk1, double r, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (k1 / 6 * (3 * Math.Pow((z - r), 2) - k2Overk1 * Math.Pow((z - r), 3) - Math.Pow(r, 3))) * Math.Cos(2*x);
        }
        static double A25_aftReflexSR(double k1, double k2Overk1, double r, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (k1 / 6 * (3 * k2Overk1 * Math.Pow((z - r), 2) - k2Overk1 * Math.Pow((z - r), 3) - Math.Pow(r, 3))) * Math.Cos(2*x);
        }
        static double A24_foreSR(double m, double p, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (2 * m / p - 2 * m * z / Math.Pow(p, 2)) * Math.Cos(2 * x);
        }
        static double A24_aftSR(double m, double p, double x)
        {
            double z = 1 / 2 * (1 - Math.Cos(x));
            return (2 * m * p / (1 - p) - 2 * m * z / Math.Pow((1 - p), 2)) * Math.Cos(2 * x);
        }

        //polar/cartesian conversion methods 
        static double CartesianToPolar(double cartesianCoord)
        {
            return (1 / 2) * (1 - Math.Cos(cartesianCoord));
        }
        static double PolarToCartesian(double polarCoord)
        {
            return Math.Acos(1 - 2 * polarCoord);
        }

        //NACA 4 analytical integrals
        static double NACA4A0IntFront(double m, double p, double theta)
        {
            return m * theta * (2 * p - 1) / Math.Pow(p, 2) + m * Math.Sin(theta) / Math.Pow(p, 2);
        }
        static double NACA4A0IntRear(double m, double p, double theta)
        {
            return m * theta * (2 * p - 1) / Math.Pow((1 - p), 2) + m * Math.Sin(theta) / Math.Pow((1 - p), 2);
        }
        static double NACA4A1IntFront(double m, double p, double theta)
        {
            return m * (2 * p - 1) * Math.Sin(theta) / Math.Pow(p, 2) + m * ((theta / 2) + Math.Sin(2 * theta)/4) / Math.Pow(p, 2);
        }
        static double NACA4A1IntRear(double m, double p, double theta)
        {
            return m * (2 * p - 1) * Math.Sin(theta) / Math.Pow((1-p), 2) + m * ((theta / 2) + Math.Sin(2 * theta) / 4) / Math.Pow((1-p), 2);
        }
        static double NACA4A2IntFront(double m, double p, double theta)
        {
            return m * (2 * p - 1) * Math.Sin(2 * theta) / (2 * Math.Pow(p, 2)) +
                m * (Math.Sin(3 * theta) / 6 + Math.Sin(theta) / 2) / Math.Pow(p, 2);
        }
        static double NACA4A2IntRear(double m, double p, double theta)
        {
            return m * (2 * p - 1) * Math.Sin(2 * theta) / (2 * Math.Pow((1-p), 2)) +
                m * (Math.Sin(3 * theta) / 6 + Math.Sin(theta) / 2) / Math.Pow((1-p), 2);
        }

        //NACA 5 normal integral coefficient equations
        static double A(double k, double r)
        {
            return k / 8 - k * r / 2 + k * Math.Pow(r, 2) * (3 - r) / 6;
        }
        static double B(double k, double r)
        {
            return k * r / 2 - k / 4;
        }
        static double C(double k)
        {
            return k / 8;
        }
        static double D(double k, double r)
        {
            return -1 * k * Math.Pow(r, 3) / 6;
        }
        //NACA 5 normal analytical integrals
        static double NACA5A0IntNormalFront(double k, double r, double theta)
        {
            return A(k, r) * theta + B(k, r) * Math.Sin(theta) + C(k) * (theta / 2 + Math.Sin(2 * theta) / 4);
        }
        static double NACA5A0IntNormalRear(double k, double r, double theta)
        {
            return D(k, r) * theta;
        }
        static double NACA5A1IntNormalFront(double k, double r, double theta)
        {
            return A(k, r) * Math.Sin(theta) + B(k, r) * (theta / 2 + Math.Sin(2 * theta) / 4) + C(k) * (Math.Sin(theta) - Math.Pow(Math.Sin(theta), 3) / 3);
        }
        static double NACA5A1IntNormalRear(double k, double r, double theta)
        {
            return D(k, r) * Math.Sin(theta);
        }
        static double NACA5A2IntNormalFront(double k, double r, double theta)
        {
            return A(k, r) * Math.Sin(2 * theta) / 2 + B(k, r) * (Math.Sin(3 * theta) / 6 + Math.Sin(theta) / 2) + C(k) * (theta / 4 + Math.Sin(2 * theta) / 4 + Math.Sin(4 * theta) / 16);
        }
        static double NACA5A2IntNormalRear(double k, double r, double theta)
        {
            return D(k, r) * Math.Sin(2 * theta) / 2;
        }

        //NACA 5 reflex integral coefficient equations
        static double Ar(double k1, double k2, double r)
        {
            return k1 / 8 - k1 * r / 2 + k1 * Math.Pow(r, 2) / 2 - k2 * Math.Pow((1 - r), 3) / 6 - k1 * Math.Pow(r, 3) / 6;
        }
        static double Br(double k1, double r)
        {
            return k1 * r / 2 - k1 / 4;
        }
        static double Cr(double k1)
        {
            return k1 / 8;
        }
        static double Dr(double k1, double k2, double r)
        {
            return k2 / 8 - k2 * r / 2 + k2 * Math.Pow(r, 2) / 2 - k2 * Math.Pow((1 - r), 3) / 6 - k1 * Math.Pow(r, 3) / 6;
        }
        static double Er(double k2, double r)
        {
            return k2 * r / 2 - k2 / 4;
        }
        static double Fr(double k2)
        {
            return k2 / 8;
        }
        //NACA 5 reflex analytical integrals
        static double NACA5A0IntReflexFront(double k1, double k2, double r, double theta)
        {
            return Ar(k1, k2, r) * theta + Br(k1, r) * Math.Sin(theta) + Cr(k1) * (theta / 2 + Math.Sin(2 * theta) / 4);
        }
        static double NACA5A0IntReflexRear(double k1, double k2, double r, double theta)
        {
            return Dr(k1, k2, r) * theta + Er(k2, r) * Math.Sin(theta) + Fr(k2) * (theta / 2 + Math.Sin(2 * theta) / 4);
        }
        static double NACA5A1IntReflexFront(double k1, double k2, double r, double theta)
        {
            return Ar(k1, k2, r) * Math.Sin(theta) + Br(k1, r) * (theta / 2 + Math.Sin(2 * theta) / 4) + Cr(k1) * (Math.Sin(theta) - Math.Pow(Math.Sin(theta), 3) / 3);
        }
        static double NACA5A1IntReflexRear(double k1, double k2, double r, double theta)
        {
            return Dr(k1, k2, r) * Math.Sin(theta) + Er(k2, r) * (theta / 2 + Math.Sin(2 * theta) / 4) + Fr(k2) * (Math.Sin(theta) - Math.Pow(Math.Sin(theta), 3) / 3);
        }
        static double NACA5A2IntReflexFront(double k1, double k2, double r, double theta)
        {
            return Ar(k1, k2, r) * Math.Sin(2 * theta) / 2 + Br(k1, r) * (Math.Sin(3 * theta) / 6 + Math.Sin(theta) / 2) + Cr(k1) * (theta / 4 + Math.Sin(2 * theta) / 4 + Math.Sin(4 * theta) / 16);
        }
        static double NACA5A2IntReflexRear(double k1, double k2, double r, double theta)
        {
            return Dr(k1, k2, r) * Math.Sin(2 * theta) / 2 + Er(k2, r) * (Math.Sin(3 * theta) / 6 + Math.Sin(theta) / 2) + Fr(k2) * (theta / 4 + Math.Sin(2 * theta) / 4 + Math.Sin(4 * theta) / 16);
        }

        //conditions for a valid NACA 5 input
        static bool NACA5AerofoilValidity(double locationData)
        {
            if (locationData == 10 ||
                locationData == 20 ||
                locationData == 30 ||
                locationData == 40 ||
                locationData == 50 ||
                locationData == 21 ||
                locationData == 31 ||
                locationData == 41 ||
                locationData == 51)
                return true;
            else
                return false;
        }        
        //method storing NACA 5 r values
        static double rValue(double locationData)
        {
            double r;
            if (locationData == 10)
            {
                r = 0.058;
                
            }
            else if (locationData == 20)
            {
                r = 0.126;                
            }
            else if (locationData == 30)
            {
                r = 0.2025;                
            }
            else if (locationData == 40)
            {
                r = 0.29;
            }
            else if (locationData == 50)
            {
                r = 0.391;
            }
            else if (locationData == 21)
            {
                r = 0.13;
            }
            else if (locationData == 31)
            {
                r = 0.217;
            }
            else if (locationData == 41)
            {
                r = 0.318;
                
            }
            else if (locationData == 51)
            {
                r = 0.441;
                
            }
            else
            {
                r = 0;
            }
            return r;
        }
        //method storing NACA 5 k1 values
        static double k1Value(double locationData)
        {
            double k1;
            if (locationData == 10)
            {
                k1 = 361.4;
            }
            else if (locationData == 20)
            {
                k1 = 51.64;
            }
            else if (locationData == 30)
            {
                k1 = 15.957;
            }
            else if (locationData == 40)
            {
                k1 = 6.643;
            }
            else if (locationData == 50)
            {
                k1 = 3.23;
            }
            else if (locationData == 21)
            {
                k1 = 51.99;
            }
            else if (locationData == 31)
            {
                k1 = 15.793;
            }
            else if (locationData == 41)
            {
                k1 = 6.52;
            }
            else if (locationData == 51)
            {
                k1 = 3.191;
            }
            else
                k1 = 0;
            return k1;
        }
        //method storing NACA 5 k ratio values
        static double k2Overk1Value(double locationData)
        {            
            double k2Overk1;
            if (locationData == 21)
            {
                k2Overk1 = 0.000764;
            }
            else if (locationData == 31)
            {
                k2Overk1 = 0.00677;
            }
            else if (locationData == 41)
            {
                k2Overk1 = 0.0303;
            }
            else if (locationData == 51)
            {
                k2Overk1 = 0.1355;
            }
            else
                k2Overk1 = 0;
            return k2Overk1;
        }

        //reset button
        private void button2_Click(object sender, EventArgs e)
        {
            //clear plot
            panel1.Refresh();
            //clear all textboxes
            textBox1.Text = string.Empty;
            textBox2.Text = string.Empty;
            textBox3.Text = string.Empty;
            textBox4.Text = string.Empty;
            textBox5.Text = string.Empty;
            textBox6.Text = string.Empty;
            textBox7.Text = string.Empty;
            textBox8.Text = string.Empty;
            textBox9.Text = string.Empty;
            textBox10.Text = string.Empty;
            textBox11.Text = string.Empty;
            textBox12.Text = string.Empty;
            textBox13.Text = string.Empty;
            textBox14.Text = string.Empty;
            textBox15.Text = string.Empty;
            textBox16.Text = string.Empty;
            
            textBox6.Visible = true;
            textBox7.Visible = true;
            textBox8.Visible = true;
            
        }

        //plot button
        private void button5_Click(object sender, EventArgs e)
        {
            //aerofoil data needed for each NACA aerofoil plot
            string aerofoil = textBox1.Text;
            double p4 = Convert.ToDouble(aerofoil.Substring(1,1))/10;
            double m4 = Convert.ToDouble(aerofoil.Substring(0, 1)) / 100;
            double locationData = Convert.ToDouble(aerofoil.Substring(1, 2));
            double k1 = k1Value(locationData);
            double r = rValue(locationData);
            double k2Overk1 = k2Overk1Value(locationData);

            //thickness of NACA 4
            double t;
            if (aerofoil.Length == 4)
                t = Convert.ToDouble(aerofoil.Substring(2, 2)) / 100;
            //thickness of NACA 5
            else
                t = Convert.ToDouble(aerofoil.Substring(3, 2)) / 100;
            

            //Clear intial data in panel
            panel1.Refresh();
            //define staring point(leading edge)
            double x = 0;
            //panel properties needed for scaling
            int w = panel1.Width;
            int h = panel1.Height / 2;
            int xWhiteSpace = 25;
            int Chord = (w - xWhiteSpace) - xWhiteSpace;

            //create arrays to hold coordinate x data
            double[] x_above = new double[200];
            double[] x_under = new double[200];
            double[] x_c = new double[200];
            //create arrays to hold coordinate x data
            double[] y_above = new double[200];
            double[] y_under = new double[200];
            double[] y_c = new double[200];

            //draw horizontal chord line in red
            Graphics plot = panel1.CreateGraphics();
            Point leadingEdge = new Point(xWhiteSpace,h);
            Point trailingEdge = new Point(w - xWhiteSpace, h);
            Point Profile = new Point((w / 2)-40, 0);
            plot.DrawLine(new Pen(Color.Red),leadingEdge,trailingEdge);
            double dy_dx = 0;
            
                //begin plot at leading edge
                //200 points per line from leading to trailing edge
                for (int i = 0; i < 200; i++)
                {
                    //camber x coordinate
                    x_c[i] = x * Chord + xWhiteSpace;

                    if (x < p4 && aerofoil.Length==4)
                    {
                        //NACA 4 front camber y coordinate and gradient 
                        y_c[i]=y4CamberFront(x,h,Chord,p4,m4);
                        dy_dx = dy_dx_fore_4(x,p4,m4);
                    }
                    else if (x > p4 && aerofoil.Length==4)
                    {
                    //NACA 4 rear camber y coordinate and gradient 
                        y_c[i] = y4CamberRear(x, h, Chord, p4, m4);
                        dy_dx = dy_dx_aft_4(x,p4,m4);
                    }
                    else if (x < r && aerofoil.Length == 5 && textBox3.Text == "normal")
                    {
                        //NACA 5 normal front camber y coordinate and gradient
                        y_c[i] =y5NormalCamberFront(x,Chord,k1,r);
                        dy_dx = dy_dx_fore_norm_5(x,k1,r);
                    }
                    else if (x > r && aerofoil.Length == 5 && textBox3.Text == "normal")
                    {
                        //NACA 5 normal rear camber y coordinate and gradient
                        y_c[i] = y5NormalCamberRear(x,Chord,k1,r);
                        dy_dx = dy_dx_aft_norm_5(x, k1, r);
                    }
                    else if (x < r && aerofoil.Length == 5 && textBox3.Text == "reflex")
                    {
                        //NACA 5 reflex front camber y coordinate and gradient
                        y_c[i] = y5ReflexCamberFront(x,Chord,k1,k2Overk1,r);
                        dy_dx = dy_dx_fore_reflex_5(x,k1,r,k2Overk1);
                    }
                    else if (x > r && aerofoil.Length == 5 && textBox3.Text == "reflex")
                    {
                        //NACA 5 reflex rear camber y coordinate and gradient  
                        y_c[i] = y5ReflexCamberRear(x,Chord,k1,r);
                        dy_dx = dy_dx_aft_reflex_5(x,k1,k2Overk1,r);
                    }

                    //thicknes distribution and theta needed at camber point
                    double theta = Math.Atan(dy_dx);
                    double y_t = (t / 0.20) * (0.2969 * Math.Sqrt(x) - 0.126 * x - 0.3516 * Math.Pow(x, 2) + 0.2843 * Math.Pow(x, 3) - 0.1015 * Math.Pow(x, 4)) * Chord;
                    
                    //use tri to plot the aerofpoil shape
                    x_above[i] = x_c[i] + y_t * Math.Sin(theta);
                    x_under[i] = x_c[i] - y_t * Math.Sin(theta);
                    y_above[i] = y_c[i] + y_t * Math.Cos(theta);
                    y_under[i] = y_c[i] - y_t * Math.Cos(theta);

                    if (i > 0)
                    {
                    //NACA 4 plot
                    if (aerofoil.Length == 4)
                    {
                        //camber
                        Point Camber1 = new Point(Convert.ToInt16(x_c[i - 1]), Convert.ToInt16(y_c[i - 1]));
                        Point Camber2 = new Point(Convert.ToInt16(x_c[i]), Convert.ToInt16(y_c[i]));
                        plot.DrawLine(new Pen(Color.Green), Camber1, Camber2);

                        //lower surface
                        Point Bottom1 = new Point(Convert.ToInt16(x_under[i - 1]), Convert.ToInt16(y_under[i - 1]));
                        Point Bottom2 = new Point(Convert.ToInt16(x_under[i]), Convert.ToInt16(y_under[i]));
                        plot.DrawLine(new Pen(Color.Black), Bottom1, Bottom2);

                        //upper surface
                        Point Upper1 = new Point(Convert.ToInt16(x_above[i - 1]), Convert.ToInt16(y_above[i - 1]));
                        Point Upper2 = new Point(Convert.ToInt16(x_above[i]), Convert.ToInt16(y_above[i]));
                        plot.DrawLine(new Pen(Color.Black), Upper1, Upper2);
                    }
                    //NACA 5 plot
                    else if (aerofoil.Length == 5)
                    {
                        //camber
                        Point Camber1 = new Point(Convert.ToInt16(x_c[i - 1]), h - Convert.ToInt16(y_c[i - 1]));
                        Point Camber2 = new Point(Convert.ToInt16(x_c[i]), h - Convert.ToInt16(y_c[i]));
                        plot.DrawLine(new Pen(Color.Green), Camber1, Camber2);

                        //lower shape
                        Point Bottom1 = new Point(Convert.ToInt16(x_under[i - 1]), h - Convert.ToInt16(y_under[i - 1]));
                        Point Bottom2 = new Point(Convert.ToInt16(x_under[i]), h - Convert.ToInt16(y_under[i]));
                        plot.DrawLine(new Pen(Color.Black), Bottom1, Bottom2);

                        //lower shape
                        Point Upper1 = new Point(Convert.ToInt16(x_above[i - 1]), h - Convert.ToInt16(y_above[i - 1]));
                        Point Upper2 = new Point(Convert.ToInt16(x_above[i]), h - Convert.ToInt16(y_above[i]));
                        plot.DrawLine(new Pen(Color.Black), Upper1, Upper2);
                    }
                    else { }

                    }
                    //step size
                    x += 0.005;
                }
        }

        //NACA 4 y coordinates and gradient of camber line for a 4-digit aerofoil
        static double y4CamberFront(double x, int h, int Chord, double p, double m)
        {
            return h - (m / Math.Pow(p, 2)) * (2 * p * x - Math.Pow(x, 2)) * Chord;
        }
        static double dy_dx_fore_4(double x, double p, double m)
        {
            return 2 * m / p - 2 * m * x / Math.Pow(p, 2);
        }
        static double y4CamberRear(double x,int h,int Chord, double p, double m)
        {
            return h - (m / Math.Pow(1 - p, 2)) * ((1 - 2 * p) + 2 * p * x - Math.Pow(x, 2)) * Chord;
        }
        static double dy_dx_aft_4(double x, double p, double m)
        {
            return 2 * p * m / Math.Pow(1 - m, 2) - 2 * m * x / Math.Pow(1 - p, 2);
        }

        //NACA 5 normal y-coordinates and gradient of camber 
        static double y5NormalCamberFront(double x, int Chord, double k1, double r)
        {
            return (k1 / 6) * (Math.Pow(x, 3) - 3 * r * Math.Pow(x, 2) + Math.Pow(r, 2) * (3 - r) * x) * Chord;
        }
        static double dy_dx_fore_norm_5(double x, double k1, double r)
        {
            return (k1 / 6) * (3 * Math.Pow(x, 2) - 6 * r * x + Math.Pow(r, 2) * (3 - r));
        }
        static double y5NormalCamberRear(double x, int Chord, double k1, double r)
        {
            return (k1 *Math.Pow(r,3)/ 6) * (1-x) * Chord;
        }
        static double dy_dx_aft_norm_5(double x, double k1, double r)
        {
            return -k1 * Math.Pow(r, 3) / 6;
        }

        //NACA 5 reflex y-coordinates and gradient of camber 
        static double y5ReflexCamberFront(double x, int Chord, double k1, double k2Overk1, double r)
        {
            return (k1 / 6) * (Math.Pow(x - r, 3) - k2Overk1 * Math.Pow(1 - r, 3) * x - Math.Pow(r, 3) * x + Math.Pow(r, 3)) * Chord;
        }
        static double dy_dx_fore_reflex_5(double x, double k1, double r, double k2Overk1)
        {
            return (k1 / 6) * (3 * Math.Pow(x - r, 2) - k2Overk1 * Math.Pow(1 - r, 3) - Math.Pow(r, 3));
        }
        static double y5ReflexCamberRear(double x, int Chord, double k1, double r)
        {
            return ((k1 * Math.Pow(r, 3) / 6) * (1 - x)) * Chord;
        }
        static double dy_dx_aft_reflex_5(double x, double k1, double k2Overk1, double r)
        {
            return (k1 / 6) * (3 * k2Overk1 * Math.Pow(x - r, 2) - k2Overk1 * Math.Pow(1 - r, 3) - Math.Pow(r, 3));
        }

        //Exit button
        private void button6_Click(object sender, EventArgs e)
        {
            this.Close();
        }
    }

}
